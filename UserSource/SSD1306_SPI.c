#include "SSD1306_SPI.h"
#include "Init_SPI.h"
//#include "stm32f0xx.h"
#include "string.h"


 uint8_t LCD_X,LCD_Y;
 static uint8_t SSD1306_Buffer_SPI[LCDWIDTH * LCDHEIGHT / 8];
 uint8_t reciever_SPI_Temp;
 

 
void LCD_Reset(void)
{
uint32_t i; //Объявляем переменную для цикла задержки
//	CS_low;
	for(i=0; i<0x00000FFF; i++);  //Задержка
	Reset_low;						//Reset Slave
	for(i=0; i<0x000FFFFF; i++);  //Задержка
	Reset_high;						//Normal Working
	for(i=0; i<0x0000FFFF; i++);  //Задержка
//	CS_high
}
//==============================================================================
void send_command(uint8_t byte_to_send)
{
//   uint32_t i; //Объявляем переменную для цикла задержки
//   CS_ON;
	if (GPIOB->IDR & GPIO_IDR_1)				//Если передаются данные, DC
	{
		while (SPI1->SR & SPI_SR_BSY);			//Ждём окончания передачи
		
      wr_Command;		                        //В режим "команда" reset bit
      //for(i=0; i<0x000000FF; i++);  //Задержка						
	}
   
//	reciever_SPI_Temp = SPI1_SendByte(byte_to_send);
//   CS_OFF;
}	
//==============================================================================
void send_data(uint8_t byte_to_send)
{
//   uint32_t i; //Объявляем переменную для цикла задержки
//   CS_ON;
	if (!(GPIOB->IDR & GPIO_IDR_1))		//Если передаётся команда, 
	{
		while (SPI1->SR & SPI_SR_BSY);			//Ждём окончания передачи
		//for(i=0; i<0x000000FF; i++);  //Задержка
      wr_Data;								//В режим "данные" set bit
      
	}
	reciever_SPI_Temp = SPI1_SendByte(byte_to_send);
//   CS_OFF;
}

void SSD1306_SPI_Fill(SSD1306_SPI_COLOR_t color) {
	/* Set memory */
	memset(SSD1306_Buffer_SPI, (color == SSD1306_SPI_COLOR_BLACK) ? 0x00 : 0xFF, sizeof(SSD1306_Buffer_SPI));
}

void SSD1306_DrawPixel_SPI(uint16_t x, uint16_t y, SSD1306_SPI_COLOR_t color) {
	if (
		x >= LCDWIDTH ||
		y >= LCDHEIGHT
	) {
		/* Error */
		return;
	}
	
	/* Check if pixels are inverted */
	if (SSD1306_SPI.Inverted) {
		color = (SSD1306_SPI_COLOR_t)!color;
	}
	
	/* Set color */
	if (color == SSD1306_SPI_COLOR_WHITE) {
		SSD1306_Buffer_SPI[x + (y / 8) * LCDWIDTH] |= 1 << (y % 8);
	} else {
		SSD1306_Buffer_SPI[x + (y / 8) * LCDWIDTH] &= ~(1 << (y % 8));
	}
}

void SSD1306_GotoXY_SPI(uint16_t x, uint16_t y) {
	/* Set write pointers */
	SSD1306_SPI.CurrentX = x;
	SSD1306_SPI.CurrentY = y;
}

char SSD1306_Putc_SPI(char ch, FontDef_t* Font, SSD1306_SPI_COLOR_t color) {
	uint32_t i, b, j;
	
	/* Check available space in LCD */
	if (
		LCDWIDTH <= (SSD1306_SPI.CurrentX + Font->FontWidth) ||
		LCDHEIGHT <= (SSD1306_SPI.CurrentY + Font->FontHeight)
	) {
		/* Error */
		return 0;
	}
	
	/* Go through font */
	for (i = 0; i < Font->FontHeight; i++) {
		b = Font->data[(ch - 32) * Font->FontHeight + i];
		for (j = 0; j < Font->FontWidth; j++) {
			if ((b << j) & 0x8000) {
				SSD1306_DrawPixel_SPI(SSD1306_SPI.CurrentX + j, (SSD1306_SPI.CurrentY + i), (SSD1306_SPI_COLOR_t) color);
			} else {
				SSD1306_DrawPixel_SPI(SSD1306_SPI.CurrentX + j, (SSD1306_SPI.CurrentY + i), (SSD1306_SPI_COLOR_t)!color);
			}
		}
	}
	
	/* Increase pointer */
	SSD1306_SPI.CurrentX += Font->FontWidth;
	
	/* Return character written */
	return ch;
}

char SSD1306_Puts_SPI(char* str, FontDef_t* Font, SSD1306_SPI_COLOR_t color) {
	/* Write characters */
	while (*str) {
		/* Write character by character */
		if (SSD1306_Putc_SPI(*str, Font, color) != *str) {
			/* Return error */
			return *str;
		}
		
		/* Increase string pointer */
		str++;
	}
	
	/* Everything OK, zero should be returned */
	return *str;
}

void 	ssd1306_SPI_Multisend(uint8_t control_byte, uint8_t* data, uint16_t count)
		{
         uint8_t i;
//			uint32_t t; //Объявляем переменную для цикла задержки
//         CS_ON;
         for (i = 0; i < count; i++) {
            if (control_byte == 0) {send_command(data[i]);} 
//            else {send_data(data[i]);}
            else {DC_On; SPI1_SendByte(data[i]);}
            //for(t=0; t<0x00008FFF; t++);  //Задержка
         }
         
          DC_Off;
//         CS_OFF;
		}
      
void SSD1306_SPI_UpdateScreen_My(void) {
	uint8_t m;
//	uint32_t i; //Объявляем переменную для цикла задержки
//   CS_ON;
	for (m = 0; m < 8; m++) {
//		send_command(0xB0 + m);
//		send_command(0x00);
//		send_command(0x10);
      SPI1_SendByte(0xB0 + m);
      SPI1_SendByte(0x00);
      SPI1_SendByte(0x10);
		//for(i=0; i<0x000FFFFF; i++);  //Задержка
		/* Write multi data */
		ssd1306_SPI_Multisend(0x40, &SSD1306_Buffer_SPI[LCDWIDTH * m], LCDWIDTH);
      
	}
//   CS_OFF;
}


//==============================================================================
uint8_t boot_logo[8][131] = 
{
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0x40, 0x40,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x30, 0xC4, 0x72, 0x0D, 0x02, 0x20, 0x50, 0xA8,0xE4, 0x08, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x0A, 0xC1, 0x7E, 0x00, 0x00, 0x00,0xE0, 0x98, 0xE2, 0x01, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x10, 0xC0, 0x00, 0x00, 0x00, 0x00,0x00, 0x80, 0x30, 0xCC, 0x12, 0x05, 0x05, 0xFC, 0x05, 0xF8, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x05,0xF9, 0x3C, 0x00, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xB0, 0x74, 0x09, 0x0C, 0xF1, 0x3E,0x00, 0x00, 0x00, 0x00, 0x80, 0xF8, 0xC5, 0x08, 0xFD, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x20,0x80, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x0E, 0xF9, 0x3C, 0x00, 0xFF, 0x00, 0x00, 0x00, 0xFE, 0x81,0x7D, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x34, 0xF2, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x3E, 0x43, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,0xFC, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x3F, 0x81, 0xF0, 0x0F, 0x80, 0xE0, 0x9C, 0x73,0xFC, 0xFF, 0xC7, 0xFC, 0x83, 0x80, 0xF0, 0xCC, 0xF3, 0xFC, 0xA0, 0xFF, 0x00, 0x00, 0x00, 0xC0,0x3C, 0x01, 0xFE, 0x03, 0x00, 0x00, 0xE0, 0xCF, 0x1C, 0x01, 0x00, 0x00, 0x00, 0xFE, 0x01, 0xFE,0x03, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xE0, 0x1E, 0xE1, 0x1F, 0x00, 0x00, 0x04, 0x01, 0x00,0x00, 0x00, 0x00, 0xC0, 0x3F, 0x30, 0xC3, 0x1E, 0x01, 0x00, 0x80, 0x60, 0x98, 0xF6, 0xF8, 0xFC,0x0F, 0x00, 0x00, 0x00, 0xFC, 0x07, 0x00, 0xFF, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x03, 0xFF, 0x0F,0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x8F, 0x3C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x80, 0xF7, 0x1F, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,0x1F, 0x70, 0x0F, 0x00, 0x00, 0x00, 0xF0, 0x1F, 0xFC, 0x7F, 0x8F, 0x33, 0x0E, 0x01, 0x80, 0xFC,0xC3, 0xFF, 0xBF, 0x6F, 0x1F, 0x07, 0x01, 0xF1, 0x7F, 0x01, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xFF,0xF0, 0x3F, 0xC7, 0x00, 0x10, 0x0A, 0x83, 0x40, 0x50, 0x10, 0x00, 0x00, 0xFC, 0x0F, 0x00, 0xFF,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x9F, 0xF0, 0x9F, 0xC0, 0x80, 0x80, 0x40, 0xA0, 0x00,0x00, 0x00, 0x00, 0xFF, 0xC0, 0xF8, 0xFF, 0x30, 0xD0, 0x2E, 0x09, 0x0A, 0xFF, 0x0F, 0xDB, 0xFF,0x00, 0x00, 0x00, 0x80, 0x7F, 0x60, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x7C,0x86, 0x87, 0xF8, 0x00, 0x00, 0xFC, 0x7B, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x08, 0x17, 0x1E, 0x2F, 0x2E, 0x14, 0x14, 0x0B, 0x04,0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x20, 0x11, 0x06, 0x01, 0x00, 0x00, 0x00, 0x07, 0x2C,0x13, 0x0C, 0x03, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xF8, 0x2D, 0x3F, 0xC0, 0x00, 0x00, 0x00, 0x07,0x10, 0x2F, 0x2F, 0x15, 0x11, 0x05, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x20, 0x10, 0x07,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x11, 0x2F, 0x2F, 0x12, 0x08, 0x03, 0x00, 0x00,0x00, 0x00, 0x00, 0x2F, 0x17, 0x0B, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x03, 0x10, 0x2F, 0x37,0x18, 0x00, 0x00, 0x03, 0x2C, 0x10, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x07, 0xF8, 0x0F, 0xE7, 0x1C, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x04, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x34, 0x82,0x25, 0x18, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00,0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
};
//==============================================================================
void show_logo(uint8_t offset)
{
	uint8_t i,j;
	for(i=0;i<LCDHEIGHT/8;i++)
	{
		LCD_Goto(0, i);
		for(j=offset;j<(offset+LCDWIDTH);j++)
		{
//			send_data(boot_logo[i][j]);
         DC_On;
         SPI1_SendByte(boot_logo[i][j]);
		}
      DC_Off;
	}
}
//==============================================================================
void LCD_Goto(uint8_t x, uint8_t y)
{
	LCD_X = x;
	LCD_Y = y;
//   CS_ON;
	// send a bunch of data in one xmission
//	send_command(x & 0xf);//set lower column address
//	send_command(0x10 | (x >> 4));//set higher column address
//	send_command(0xB0 + y);//set page address
   SPI1_SendByte(x & 0xf);//set lower column address
	SPI1_SendByte(0x10 | (x >> 4));//set higher column address
	SPI1_SendByte(0xB0 + y);//set page address
//   CS_OFF;
   
}
//==============================================================================
void Fill_RAM(unsigned char Data)
{
	uint8_t i,j;
//   CS_ON;
		for(i=0;i<LCDHEIGHT/8;i++)
		{
			LCD_Goto(0, i);
			for(j=0;j<LCDWIDTH;j++)
			{
//				send_data(Data);
            DC_On;
            SPI1_SendByte(Data);
            DC_Off;
			}
		}
//    CS_OFF;  
}
//==============================================================================
uint8_t LCD_Init_sequence[28] = 
{
//0xAF,     // Display Off** 

//0xD5,     // clock
//0x80,     // upper nibble is rate, lower nibble is divisor***

//0xA8,     // Set multiplex ratio
//0x3F,     // rtfm

//0xD3,     // Set Display Offset 0xD3
//0x00,     // no offset

//0x40,     // Set display start line

//0x8D,     // Set charge pump
//0x14,     // 0x10 - Suplied Externally

//0xA1,     // Segrment remap - 0xA1 (A0->SEG0=column0, A1->SEG0=column127)

//0xC8,     // Set COM output scan Direction (C0=up, C8=down)

//0xDA,     // Seet COM pins hardware configuration
//0x12,     //  bits [5],[4] & b1=1
//	
//0x81,     // Set Contrast 0x81
//0xCF,     // 0x9F - Suplied Externally (CF)
//	
//0xD9,     // Set Pre-Charge period
//0xF1,     // 0x22 - Suplied Externally
//	
//0xDB,     // Set VCOMH Deselect Level
//0x70,     // 
//	
//0xA4,     // Set entire DISPLAY on/off
//	
//0xA6,     // Normal Display 0xA6 (Invert A7)
//	
//0x20,     // Set Memory Addressing Mode
//0x02     // Default => 0x02

0xAF, //display on AE - off
0x20, //Set Memory Addressing Mode   
0x10, //00,Horizontal Addressing Mode;01,Vertical Addressing Mode;10,Page Addressing Mode (RESET);11,Invalid
0xB0, //Set Page Start Address for Page Addressing Mode,0-7
0xC8, //Set COM Output Scan Direction
0x00, //---set low column address
0x10, //---set high column address
0x40, //--set start line address
0x81, //--set contrast control register
0xFF,
0xA1, //--set segment re-map 0 to 127
0xA6, //--set normal display
0xA8, //--set multiplex ratio(1 to 64)
0x3F, //
0xA4, //0xa4,Output follows RAM content;0xa5,Output ignores RAM content
0xD3, //-set display offset
0x00, //-not offset-------------------
0xD5, //--set display clock divide ratio/oscillator frequency
0xF0, //--set divide ratio
0xD9, //--set pre-charge period
0x22, //
0xDA, //--set com pins hardware configuration
0x12,
0xDB, //--set vcomh
0x20, //0x20,0.77xVcc
0x8D, //--set DC-DC enable
0x14, //
0xAF //--turn on SSD1306 panel

};
void LCD1_init(void)
{
	uint8_t x;
//   uint32_t i; //Объявляем переменную для цикла задержки
//	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN; //Тактирование порта A
////#ifdef	wr_Data
//	GPIOA->CRL |= GPIO_CRL_MODE3; //Вывод PA3 порта A настроен как выход
//	GPIOA->CRL &= ~GPIO_CRL_CNF3_0; //Режим Push-Pull для вывода PA3 порта A
////#endif
////#ifdef	Reset_high
//	GPIOA->CRL |= GPIO_CRL_MODE2; //Вывод PA2 порта A настроен как выход
//	GPIOA->CRL &= ~GPIO_CRL_CNF2_0; //Режим Push-Pull для вывода PA2 порта A
//#endif
//	CS_low;
//   CS_OFF;
   CS_ON;
	for (x=0; x<28; x++)
		{
//			send_command(LCD_Init_sequence[x]);
         SPI1_SendByte(LCD_Init_sequence[x]);
//         for(i=0; i<0x000FFFFF; i++);  //Задержка
		}
//      
	Fill_RAM(0x00);             // 0 - Clear Screen 1 - white
		//send_command(0xAF);     // Display On
CS_OFF;
//	CS_high;
}

void LCD2_init(void)
{
	uint8_t x;
//   uint32_t i; //Объявляем переменную для цикла задержки
//	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN; //Тактирование порта A
////#ifdef	wr_Data
//	GPIOA->CRL |= GPIO_CRL_MODE3; //Вывод PA3 порта A настроен как выход
//	GPIOA->CRL &= ~GPIO_CRL_CNF3_0; //Режим Push-Pull для вывода PA3 порта A
////#endif
////#ifdef	Reset_high
//	GPIOA->CRL |= GPIO_CRL_MODE2; //Вывод PA2 порта A настроен как выход
//	GPIOA->CRL &= ~GPIO_CRL_CNF2_0; //Режим Push-Pull для вывода PA2 порта A
//#endif
//	CS_low;
//   CS_OFF;
   CS2_ON;
	for (x=0; x<28; x++)
		{
//			send_command(LCD_Init_sequence[x]);
         SPI1_SendByte(LCD_Init_sequence[x]);
//         for(i=0; i<0x000FFFFF; i++);  //Задержка
		}
//      
	Fill_RAM(0x00);             // 0 - Clear Screen 1 - white
		//send_command(0xAF);     // Display On
CS2_OFF;
//	CS_high;
}

void SSD1351_Init_SPI(void)
{
	uint8_t i,j;
	
	CS_ON;
	wr_Command;SPI1_SendByte(0xFD); //Command lock setting
	wr_Data;SPI1_SendByte(0x12); //unlock
	wr_Command;SPI1_SendByte(0xFD);//Command lock setting
	wr_Data;SPI1_SendByte(0xB1); //unlock
	
	wr_Command;	SPI1_SendByte(0xAE);//Display oFF
	
	SPI1_SendByte(0xB3); //clock & frequency
  wr_Data;SPI1_SendByte(0xF1); //clock=Diviser+1 frequency=fh 
	
  wr_Command;SPI1_SendByte(0xCA); //Duty
	wr_Data;SPI1_SendByte(0x7F); //OLED _END+1
	
	wr_Command;SPI1_SendByte(0xA2); //Display offset
	wr_Data;SPI1_SendByte(0x00);
	
	wr_Command;SPI1_SendByte(0xA1); //Set display start line
	wr_Data;SPI1_SendByte(0x00); //0x00 start line
	
	wr_Command;SPI1_SendByte(0xA0); //Set Re-map, color depth
	wr_Data;SPI1_SendByte(0xA0); //8-bit 262K
	
	wr_Command;SPI1_SendByte(0xB5); //set GPIO
	wr_Data;SPI1_SendByte(0x00); //disabled
	
	wr_Command;SPI1_SendByte(0xAB); //Function Set
	wr_Data;SPI1_SendByte(0x01); //8-bit interface, internal VDD regulator
	
	wr_Command;SPI1_SendByte(0xB4); //set VSL
	wr_Data;SPI1_SendByte(0xA0); //external VSL
	wr_Data;SPI1_SendByte(0xB5); 
	wr_Data;SPI1_SendByte(0x55);

	wr_Command;SPI1_SendByte(0xC1); //Set contrast current for A,B,C
	wr_Data;SPI1_SendByte(0x8A); //Color A //8a
	wr_Data;SPI1_SendByte(0x51); //Color B //51
	wr_Data;SPI1_SendByte(0x8A); //Color C //8a
	
	wr_Command;SPI1_SendByte(0xC7); //Set master contrast
	wr_Data;SPI1_SendByte(0x0F); 
	
	wr_Command;SPI1_SendByte(0xB9); //use linear grayscale LUT
	
	wr_Command;SPI1_SendByte(0xB1); //Set pre & dis-charge
	wr_Data;SPI1_SendByte(0x32);//pre=1h, dis=1h 
	
	wr_Command;SPI1_SendByte(0xBB); //Set precharge voltage of color A,B,C
	wr_Data;SPI1_SendByte(0x07);
	
	wr_Command;SPI1_SendByte(0xB2); //display enhancement
	wr_Data;SPI1_SendByte(0xA4); 
	wr_Data;SPI1_SendByte(0x00); 
	wr_Data;SPI1_SendByte(0x00); 
	
	wr_Command;SPI1_SendByte(0xB6); //precharge period
	wr_Data;SPI1_SendByte(0x01);
	
	wr_Command;SPI1_SendByte(0xBE); //Set VcomH
	wr_Data;SPI1_SendByte(0x07);
	
	wr_Command;SPI1_SendByte(0xA6); //Normal display
	
	wr_Command;SPI1_SendByte(0x15); //set column start and end addresses
	wr_Data;SPI1_SendByte(0x00);
	wr_Data;SPI1_SendByte(0x7F);
	wr_Command;SPI1_SendByte(0x75); //set row start and end addresses
	wr_Data;SPI1_SendByte(0x00);
	wr_Data;SPI1_SendByte(0x7F);
	
	wr_Command;SPI1_SendByte(0x5C); //write to RAM command
	for(i=0;i<128;i++)
	{
		for(j=0;j<128;j++)
		{
		wr_Data;SPI1_SendByte(0x00);
		wr_Data;SPI1_SendByte(0x00);
		wr_Data;SPI1_SendByte(0x00);
	}
	}
	
	wr_Command;	SPI1_SendByte(0xAF);//Display on
	
	
	
	CS_OFF;
}



